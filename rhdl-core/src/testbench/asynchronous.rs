use crate::{
    hdl::ast::{
        assert, assign, bit_string, component_instance, connection, declaration, delay, display,
        dump_file, dump_vars, finish, id, initial, unsigned_width, Direction, HDLKind, Module,
    },
    sim::waveform::{waveform, AsynchronousWaveform},
    types::bit_string::BitString,
    Circuit, RHDLError, TimedSample,
};

use super::{test_module::TestModule, TestModuleOptions};

fn build_test_module_from_waveform(
    hdl: &Module,
    waveform: &AsynchronousWaveform,
    config: &TestModuleOptions,
) -> Result<TestModule, RHDLError> {
    // All synchronous modules must have at least 1
    // ports.  They may have 2 if hte circuit takes input signals.
    let has_nonempty_input = hdl.ports.len() == 2;
    let output_port = if has_nonempty_input {
        &hdl.ports[1]
    } else {
        &hdl.ports[0]
    };
    if has_nonempty_input == waveform.input_kind.is_empty() {
        return Err(RHDLError::TestbenchConstructionError(
            "Input port mismatch".into(),
        ));
    }
    if has_nonempty_input && waveform.input_kind.bits() != hdl.ports[0].width.len() {
        return Err(RHDLError::TestbenchConstructionError(
            "Input port width mismatch".into(),
        ));
    }
    if output_port.direction != Direction::Output
        || output_port.width.len() != waveform.output_kind.bits()
    {
        return Err(RHDLError::TestbenchConstructionError(
            "Output port mismatch".into(),
        ));
    }
    let arg1_connection = (has_nonempty_input).then(|| connection(&hdl.ports[0].name, id("i")));
    let arg2_connection = Some(connection(&output_port.name, id("o")));
    let uut_name = &hdl.name;
    let instance = component_instance(
        uut_name,
        "t",
        vec![arg1_connection, arg2_connection]
            .into_iter()
            .flatten()
            .collect(),
    );
    let declarations = vec![
        (has_nonempty_input).then(|| {
            declaration(
                HDLKind::Reg,
                "i",
                unsigned_width(waveform.input_kind.bits()),
                None,
            )
        }),
        Some(declaration(
            HDLKind::Wire,
            "o",
            unsigned_width(waveform.output_kind.bits()),
            None,
        )),
        Some(declaration(
            HDLKind::Reg,
            "rust_out",
            unsigned_width(waveform.output_kind.bits()),
            None,
        )),
    ];
    let mut test_cases = vec![];
    if let Some(vcd_file) = &config.vcd_file {
        test_cases.push(dump_file(vcd_file));
        test_cases.push(dump_vars(0));
    }
    let mut extra_delay = 0;
    for (test_case_counter, timed_entry) in waveform.entries.iter().enumerate() {
        test_cases.push(delay(
            (timed_entry.delay as usize).saturating_sub(extra_delay),
        ));
        let input = timed_entry.input.clone();
        if has_nonempty_input {
            test_cases.push(assign("i", bit_string(&BitString::unsigned(input))));
        }
        let output = timed_entry.output.clone();
        test_cases.push(assign("rust_out", bit_string(&BitString::unsigned(output))));
        test_cases.push(delay(config.hold_time as usize));
        extra_delay = config.hold_time as usize;
        if test_case_counter < config.skip_first_cases {
            continue;
        }
        test_cases.push(assert(id("o"), id("rust_out"), test_case_counter));
    }
    test_cases.push(display("TESTBENCH OK", vec![]));
    test_cases.push(finish());
    let module = Module {
        name: "testbench".into(),
        description: format!("Autogenerated testbench for {}", hdl.name),
        declarations: declarations.into_iter().flatten().collect(),
        statements: vec![instance, initial(test_cases)],
        submodules: vec![hdl.clone()],
        ..Default::default()
    };
    Ok(module.into())
}

pub fn test_asynchronous_hdl<T: Circuit>(
    uut: &T,
    inputs: impl Iterator<Item = TimedSample<T::I>>,
) -> Result<(), RHDLError> {
    // Get a waveform for this circuit
    let wav = waveform(uut, inputs);
    let rtl_mod = uut.hdl("uut")?.as_module();
    let tm1 = build_test_module_from_waveform(&rtl_mod, &wav, &Default::default())?;
    tm1.run_iverilog()?;
    let fg = uut.flow_graph("uut")?.hdl("uut")?;
    let tm1 = build_test_module_from_waveform(&fg, &wav, &Default::default())?;
    tm1.run_iverilog()?;
    Ok(())
}

pub fn build_rtl_testmodule<T: Circuit>(
    uut: &T,
    inputs: impl Iterator<Item = TimedSample<T::I>>,
    options: TestModuleOptions,
) -> Result<TestModule, RHDLError> {
    let wav = waveform(uut, inputs);
    let module = if options.flow_graph_level {
        &uut.flow_graph("uut")?.hdl("uut")?
    } else {
        &uut.hdl("uut")?.as_module()
    };
    build_test_module_from_waveform(module, &wav, &options)
}
